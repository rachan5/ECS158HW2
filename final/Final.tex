\documentclass[11pt,letterpaper]{article}

\usepackage[margin=1in]{geometry}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{color}
\usepackage{textcomp}
%\usepackage{bbm}
%\usepackage{url}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygrey}{rgb}{0.5,0.5,0.5}
\definecolor{listinggray}{gray}{0.5}
\definecolor{lbcolor}{rgb}{0.8,0.8,0.8}

\lstdefinestyle{numbers} {numbers=left, stepnumber=1, numberstyle=\tiny, numbersep=10pt}
\lstdefinestyle{MyFrame}{backgroundcolor=\color{yellow},frame=shadowbox}

\lstdefinestyle{MyC++Style} {
backgroundcolor=\color{white},
    tabsize=4,    
%   rulecolor=,
    language=[GNU]C++,
        basicstyle=\scriptsize,
        upquote=true,
        aboveskip={1.5\baselineskip},
        columns=fixed,
        showstringspaces=false,
        extendedchars=false,
        breaklines=true,
        prebreak = \raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
        frame=single,
        numbers=left,
        showtabs=false,
        showspaces=false,
        showstringspaces=false,
        identifierstyle=\ttfamily,
        keywordstyle=\color[rgb]{0,0,1},
        commentstyle=\color[rgb]{0.026,0.112,0.095},
        stringstyle=\color[rgb]{0.627,0.126,0.941},
        numberstyle=\color[rgb]{0.205, 0.142, 0.73},
}

\lstdefinestyle{MyR}{
	backgroundcolor = \color{white},
	commentstyle  = \color{mygreen},
	frame = single,
	keywordstyle = \color{blue},
	language = R,
	numbers = left,
	numbersep = 8pt,
	numberstyle = \color{mygrey},
}

\lstset{backgroundcolor=\color{lbcolor},
  tabsize=4,
  language=C++,
  captionpos=b,
  frame=lines,
  numbers=left,
  numberstyle=\tiny,
  numbersep=5pt,
  breaklines=true,
  showstringspaces=false,
  basicstyle=\footnotesize,
%  identifierstyle=\color{magenta},
  keywordstyle=\color[rgb]{0,0,1},
  commentstyle=\color{Darkgreen},
  stringstyle=\color{red}}
  
\lstset{language=R,frame=none}

% Use this space to define/redefine commands.  This is a really useful trick if there's some 
% command sequence that you use quite frequently that you don't want to have to type over and over.
% For example, here I define new commands for floor and ceiling.  The syntax is
% 
% \newcommand{\commandname}[numberofargs]{stuff here}
%
% Use #1, #2, etc. in the "stuff here" section to refer to your arguments.  Here I define commands
% for "floor" and "ceiling"

\newcommand{\floor}[1]{{\left\lfloor #1 \right\rfloor}}
\newcommand{\ceil}[1]{{\left\lceil #1 \right\rceil}}

% Here I'm defining a theorem to be used later.  The syntax is
% \newtheorem{theoremname}{Text}

\newtheorem{thm1}{Theorem}

% I don't like the default proof symbol for the theorems, so I made my own.  (You can use this 
% command to redefine any LaTeX command you want.  Be careful, though!  This may break things!
% The syntax is identical to the \newcommand macro.)
\renewcommand{\qedsymbol}{$\scriptstyle\blacksquare$}

% All of your content needs to go between \begin{document}...\end{document}
\begin{document}

% You can use \begin{flushright}...\end{flushright} to right-justify your text, as well.  To change
% text size, choose one of (in decreasing order) \Huge, \huge, \LARGE, \Large, \large, \small,
% \footnotesize, \tiny.  By default, your text is \normalsize.
\begin{center}
{\huge \textbf{ECS 158 Final Project: An Attempt At Parallelizing R's Phylobase::ShortestPath()}\\
\vspace{5mm}
\begin{Large}
Raymond S. Chan, Alicia Luu, Bryan Ng\\
raschan@ucdavis.edu, ajuu@ucdavis.edu, bng@ucdavis.edu\\
\end{Large}}
\end{center}

% You can create sections, subsections, and subsubsections this way.  You can \label them and
% reference later in the document:

\vspace{5mm}

\begin{center}
	\begin{large}
		\textbf{Abstract}\\
This report attempts to parallelize CRAN's phylobase package's shortestPath function in RSnow, OpenMP and CUDA. The function takes in a phylogeneic tree and produces the shortest path between two nodes. The RSnow implementation is built on top of the existing code and parallelizes the descendants function. The OpenMP implementation took a similar approach by parallelizing both the ancestors and descendants C functions. The CUDA implementation took the brute force approach to the shortestPath problem. Overall, our attempt to parallelize the shortest path function was partially successful.The original version has shown that it is quite fast and efficient in finding the shortest path. \\
	\end{large}
\end{center}

\section{Introduction and Motivation}
 
Alongside the rise of "big data" in the recent years, bioinformatics has gained considerable momentum. But the a consistent issue remains: what do we do with all the data and how do we make sense of it at a reasonable rate? The R community has attempted to resolute these issues. For this report, we are examining the R's phylobase package, which provides the base class and functions for phylogenetic or evolutionary structures and comparative data. We will be focusing our efforts in making the "treewalk" utility functions, such as finding descendants/ancestors and shortest paths quickly through three different parallel programming models (RSnow, OpenMP and CUDA).  


\section{Approaches}

Only pseudocode or key chunks of code of each implementation are shown or described,
see Appendix A for code details.

\subsection{Original}
The original R implementation calculated the shortest path betweeen the two nodes of interest by first calculating their Most Recent Common Ancestor (MRCA). The MRCA's descendants are then calculated and compared to the the two nodes's ancestors. Any overlap is stored and that is the shortest path. \\
The C version of the descendants function, called Cdescendant(), works by first marking a given node in a preordered list of edges. The direct descendants (or children) of the given node are then marked. Cdescendant() then iterates through the other edges and marks each marked node's direct descendants (children).\\
The C version of the ancestors function works the same as Cdescendants, but direct \textit{ancestors} (or parents) are marked instead of direct \textit{descendants} (children).

Pseudocode (source code in original phylobase package):
\begin{lstlisting}[style=MyR]
descendants(tree, given_node){
	#let x be the edges of tree listed in PREORDER,
	#with the older node occupying the first column
	# C function call
	isDescendant <- Cdescendants(x[,1], x[,2], given_node)
	retval <- getNode(tree, isDescendant)
}

ancestors(tree, node1){
	#let x be the edges of tree listed in POSTORDER,
	#with the older node occupying the first column
	# C function call
	isAncestor <- Cancestors(x[,1], x[,2], given_node)
	retval <- getNode(tree, isAncestor)
}

MRCA(tree, node1, node2 ... noden){
	nodes <- unique(node1, node2, ..., noden)
	ancests <- lapply(nodes, ancestors, phy=phy, type="ALL")
    retval <- getNode(phy, max(Reduce(intersect, ancests)))
}
shortestPath(tree, node1, node2){
     t1 <- getNode(tree, node1)
     t2 <- getNode(tree, node2)

     # most recent common ancestor
     comAnc <- MRCA(tree, t1, t2) 
     desComAnc <- descendants(tree, comAnc)

     # path: common ancestor to t1
     ancT1 <- ancestors(x, t1)
     path1 <- intersect(desComAnc, ancT1) 

     # path: common ancestor to t2
     ancT2 <- ancestors(x, t2)
     path2 <- intersect(desComAnc, ancT2)

     # union of the path above paths
     retval <- union(path1, path2)
}
\end{lstlisting}

\newpage

\subsection{RSnow}
The RSnow implementaion builds on top of original R version by parallelizing the descendants function. 
In order to make independent subproblems, for a given node, every other node keeps marching upwards to its ancestors until they either reached the root or encountered the given node. 
We were unable to parallelize the ancestor function. The original R version seems to have taken the most efficent serial approach for calculating a given node's ancestors. \\

Pseudocode: (see code in Appendix A.1)
\begin{lstlisting}[style=MyR]
descendants(tree, given_node){
     #let x be the list of all nodes except the given_node
     for i from 1 to height of tree
          if x == given_node -> append node to retval
          update x with its correponding ancestor
     return retval
}
\end{lstlisting}

\subsection{OpenMP}
OpenMP allows parallelism to be added without changing a significant amount of existing code. And that's exactly what we did implement to implement an OpenMP version of the original shortestPath program. 
We decided to parallelize the two serial C functions called and implied by the shortestPath function in treewalk.R.
Those two C functions are ancestors() in ancestors.c and descendants() in descendants.c. 
Because serial “for” loops comprised the bulk of the ancestor and descendant C functions, the OpenMP implementation is embarrassingly parallel. The functions are also small so there isn't a need for explicit barriers.\\

See code in Appendix A.2.\\

\subsection{CUDA}
Our CUDA implementation of the shortestPath function utilizes the GPU to find all ancestors of a given pair of nodes and then construct the shortest path between them. 
Our implementation assumes CSIF's pc43's resources, which are 1024 threads per block and 1 GB of global memory. We assume the given data can fit in our GPU’s global memory. 
This assumption may limit the test we will be able to perform. 
Our solution utilizes the fact that the shortest path between two nodes in a tree must converge at the lowest common ancestor of both nodes. 
In cases, where one node is an ancestor of another, the shortest path is then found by traversing the parents of the child node. 
We parallelized our code by finding both sets of ancestors of the given nodes at the same time. 
Since neither node needs to know about the other to find its own ancestors, this problem can be done independently of each other. 
Both sets of ancestors are then traversed to find the shortest path. 
We were unable to parallelize this part of the solution since each list of ancestors must be checked to find overlapping elements. \\

See code in Appendix A.3.\\

\section{Experiment Results}

These are the unprocessed results from using R's system.time() on the RSnow and OMP shortestPath functions on testXXX.tre test cases, where XXX denotes the numbers of leaves the tree has. The serial label denotes the original R implementation. We did not manage to get the CUDA implemetation to correctly interface with R.
\begin{verbatim}
#msdir/set1/test10.tre
#serial 
c(0.015, 0.011, 0.012, 0.012, 0.012, 0.011, 0.012, 0.008, 0.011, 0.012)
#RSnow
c(0.068, 0.017, 0.018, 0.017, 0.017, 0.017, 0.017, 0.018, 0.017, 0.019)
#OMP
c(0.016, 0.011, 0.012, 0.011, 0.011, 0.012, 0.011, 0.009, 0.012, 0.011)

#msdir/set1/test100.tre
#serial
c(0.027, 0.030, 0.022, 0.020, 0.020, 0.021, 0.021, 0.020, 0.021, 0.021)
#RSnow
c(0.155, 0.132, 0.117, 0.118, 0.130, 0.125, 0.136, 0.111, 0.115, 0.114)
#OMP
c(0.046, 0.025, 0.021, 0.021, 0.021, 0.020, 0.021, 0.021, 0.020, 0.021)

#msdir/set1/test1000.tre
#serial
#c(0.131, 0.128, 0.125, 0.122, 0.124, 0.136, 0.129, 0.123, 0.123, 0.126)
#RSnow
c(16.454, 17.481, 16.778, 17,686, 12.808, 16.032, 15.914, 16.816, 13.582, 14.389)
#OMP 
#c(0.132, 0.130, 0.151, 0.124, 0.133, 0.134, 0.125, 0.124, 0.123, 0.126)

#msdir/set1/test10000.tre
#serial
c(1.819, 1.851, 1.850, 1.789, 1.754, 1.840, 1.809, 1.699, 1.735, 1.787)
#RSnow
c(0,0,0,0,0,0,0,0,0,0) #program crashed on this case
#OMP
c(1.783, 1.841, 1.820, 1.751, 1.805, 1.830, 1.796, 1.705, 1.733, 1.784)
\end{verbatim}

\section{Discussion}

\subsection{RSnow}
The RSnow version was tested with four localhost worker nodes. The large majority of its runs were slower than the serial version. Looking back at our appraoch to the prolem, it was quite resource, specifically memory hungry. It was not a good idea for have four localhost nodes tackle the issue. \\

\subsection{OpenMP}
The OpenMP version works marginally faster than the original code on large phylogenic trees (approximately 10000 leaves). With small trees, serial "for" loops seem to be efficient in finding ancestor and decsendent nodes. \\

\subsection{CUDA}

Compared to the serial version, the cuda implementation performed slower in most test cases. While the cuda version can compute both given node’s ancestors at the same time, it must also load the entire tree into the GPU’s memory.\\


\section{Conclusion}
In the attempt to parallelize the shortest path function in the phylobase package, the RSnow implementation illustrated the efficiency of the original code and its serial search algorithm. The OpenMP implementation showed the utility of multithreading for large data. The CUDA implementation could not be timed, because of R/C interafacing issues. 


\section{Acknowledgements}
We would like to thank Professor Norman Matloff for his guidance and knowledge presented during lectures. This work is the result of a final project for ECS 158 Winter Quarter 2015.  His open-source textbook, blog and various tutorial were an essential part of our learning. We would also like to thank the teaching assistance Shengren Li for offering invaluble advice and feedback on our codes (especically our CUDA) throughout the quarter.

\newpage

\section{Appendix}

\appendix
\section{Codes} \label{App:AppendixA}
% the \\ insures the section title is centered below the phrase: AppendixA

INSERT ALL CODES HERE ALONG WITH A PARAGRAPH EXPLAINING IT
\subsection{RSnow Code}
\begin{lstlisting}[style=MyR]
SNOW <- function(x,size,root,type=c("descendants")){
    ans <- rep(0,size)
    mystart <- (myid-1)*length(x)+1
    myend <- myid*length(x)

    type <- match.arg(type)
    if (type == "descendants"){
        v1 <- descendant
        v2 <- ancestor
        #initalization
        temp <- v1[mystart:myend]

        #second and beyond iteration
        for (j in 1:size){
            if (node %in% temp){
                setthese <- which(temp == node) + mystart-1
                ans[setthese] <- 1
            }
            blah <- rep(-1,length(temp))
            for (i in (1:length(temp))){
                matched_pos <- which(v1 == temp[i])
                if (length(matched_pos) != 0){
                    blah[which(temp == temp[i])] <- matched_pos
                }
                else{#matched_pos == 0
                    ## R is 1 INDEXED!
                    if (type == "descendants"){
                        blah[i] <- 1
                    }
                }
            }#for i 
            #"go to your parents set"
            difference <- length(temp) - length(v2[blah])
            temp <- v2[blah]
            if (difference > 0){
                temp <- c(rep(0,difference),temp)
            }
            if (node %in% temp){
                setthese <- which(temp == node) + mystart-1
                ans[setthese] <- 1
            }
        }#j loop
    }#new endif for type==descendants
    return(ans)
}# end SNOW

setmyid <- function(i){
    myid <<- i
}

## get descendants with RSnow
RSnowdescendants <- function (phy, node, type=c("tips","children","all"),cls) {
    type <- match.arg(type)

    ## look up nodes, warning about and excluding invalid nodes
    oNode <- node
    node <- getNode(phy, node, missing="warn")
    isValid <- !is.na(node)
    node <- as.integer(node[isValid])

    if (type == "children") {
        res <- lapply(node, function(x) children(phy, x))
        ## if just a single node, return as a single vector
        if (length(res)==1) res <- res[[1]]
    } else {
        ## edge matrix must be in preorder for the C function!
        #if (phy@order=="preorder") {
            edge <- phy@edge
        #} else {
        #    edge <- reorder(phy, order="postorder")@edge
        #}
        ## extract edge columns
        ancestor <- as.integer(edge[, 1])
        descendant <- as.integer(edge[, 2])

        ## return indicator matrix of ALL descendants (including self)
        #isDes <- .Call("descendants", node, ancestor, descendant)
        clusterExport(cls,c("node", "ancestor", "descendant","setmyid","SNOW"), envir=environment())
        dexgrps <- splitIndices(length(ancestor),length(cls))
        rootdex <- which(phy@edge[,1] == 0)
        clusterApply(cls,1:length(cls),setmyid)
        newisDes <- clusterApply(cls,dexgrps,SNOW,length(ancestor),rootdex,     "descendants")
        isDes <- (matrix(Reduce('+',newisDes),nrow=length(ancestor),ncol=1))
        storage.mode(isDes) <- "logical"
        ## for internal nodes only, drop self (not sure why this rule?)
        int.node <- intersect(node, nodeId(phy, "internal"))
        isDes[cbind(match(int.node, descendant),
            match(int.node, node))] <- FALSE

        ## if only tips desired, drop internal nodes
        if (type=="tips") {
            isDes[descendant %in% nodeId(phy, "internal"),] <- FALSE
        }
        ## res <- lapply(seq_along(node), function(n) getNode(phy,
        ##     descendant[isDes[,n]]))
        res <- getNode(phy, descendant[isDes[, seq_along(node)]])
    }
    ## names(res) <- as.character(oNode[isValid])

    res
}

###############
# shortestPath
###############

RSnowshortestPath <- function(phy, node1, node2,cls){

    ## conversion from phylo, phylo4 and phylo4d
    if (class(phy) == "phylo4d") {
        x <- extractTree(phy)
    }
    else if (class(phy) != "phylo4"){
        x <- as(phy, "phylo4")
    }
    ## some checks
    t1 <- getNode(x, node1)
    t2 <- getNode(x, node2)
    if(any(is.na(c(t1,t2)))) stop("wrong node specified")
    if(t1==t2) return(NULL)

    ## main computations
    comAnc <- MRCA(x, t1, t2) # common ancestor
    desComAnc <- RSnowdescendants(x, comAnc, type="all",cls)
    ancT1 <- ancestors(x, t1, type="all")
    path1 <- intersect(desComAnc, ancT1) # path: common anc -> t1

    ancT2 <- ancestors(x, t2, type="all")
    path2 <- intersect(desComAnc, ancT2) # path: common anc -> t2

    res <- union(path1, path2) # union of the path
    ## add the common ancestor if it differs from t1 or t2
    if(!comAnc %in% c(t1,t2)){
        res <- c(comAnc,res)
    }

    res <- getNode(x, res)

    return(res)
} # end shortestPath

\end{lstlisting}

\subsection{OpenMP Code}
\begin{lstlisting}[style=MyC++Style]

#include <R.h>
#include <Rinternals.h>
#include "omp.h"
int num_threads=8;
void omp_set_num_threads(int num_threads);

SEXP OMPancestors(SEXP nod, SEXP anc, SEXP des) {

    int numEdges = length(anc);
    int numNodes = length(nod);

    int* nodes = INTEGER(nod);
    int* ancestor = INTEGER(anc);
    int* descendant = INTEGER(des);

    int parent = 0;
    SEXP isAncestor;

    PROTECT(isAncestor = allocMatrix(INTSXP, numEdges, numNodes));
 #pragma omp parallel for collapse(2)
    for (int n=0; n<numNodes; n++) {
	//#pragma omp parallel for
        for (int i=0; i<numEdges; i++) {
            if (nodes[n]==descendant[i]) {
                INTEGER(isAncestor)[i + n*numEdges] = 1;
            } else {
                INTEGER(isAncestor)[i + n*numEdges] = 0;
            }
        }
    }

#pragma omp parallel for collapse(2)
    for (int n=0; n<numNodes; n++) {
	//#pragma omp parallel for
        for (int i=0; i<numEdges; i++) {
            if (INTEGER(isAncestor)[i + n*numEdges]==1) {
                parent = ancestor[i];
                for (int j=i+1; j<numEdges; j++) {
                    if (descendant[j]==parent) {
                        INTEGER(isAncestor)[j + n*numEdges]=1; 
                    }
                }
            }
        }
    }

    UNPROTECT(1);
    return isAncestor;
}

SEXP OMPdescendants(SEXP nod, SEXP anc, SEXP des) {

    int numEdges = length(anc);
    int numNodes = length(nod);

    int* nodes = INTEGER(nod);
    int* ancestor = INTEGER(anc);
    int* descendant = INTEGER(des);

    int child = 0;
    SEXP isDescendant;

    PROTECT(isDescendant = allocMatrix(INTSXP, numEdges, numNodes));
#pragma omp parallel for collapse(2) 
   for (int n=0; n<numNodes; n++) {
        for (int i=0; i<numEdges; i++) {
            if (nodes[n]==descendant[i]) {
                INTEGER(isDescendant)[i + n*numEdges] = 1;
            } else {
                INTEGER(isDescendant)[i + n*numEdges] = 0;
            }
        }
    }

#pragma omp parallel for collapse(2)
    for (int n=0; n<numNodes; n++) {
        for (int i=0; i<numEdges; i++) {
            if (INTEGER(isDescendant)[i + n*numEdges]==1) {
                child = descendant[i];
                for (int j=i+1; j<numEdges; j++) {
                    if (ancestor[j]==child) {
                        INTEGER(isDescendant)[j + n*numEdges] = 1; 
                    }
                }
            }
        }
    }
    UNPROTECT(1);
    return isDescendant;
}
\end{lstlisting}

\begin{lstlisting}[style=MyR]
## get descendants [recursively]
OMPdescendants <- function (phy, node, type=c("tips","children","all")) {
    type <- match.arg(type)

    ## look up nodes, warning about and excluding invalid nodes
    oNode <- node
    node <- getNode(phy, node, missing="warn")
    isValid <- !is.na(node)
    node <- as.integer(node[isValid])

    if (type == "children") {
        res <- lapply(node, function(x) children(phy, x))
        ## if just a single node, return as a single vector
        if (length(res)==1) res <- res[[1]]
    } else {
        ## edge matrix must be in preorder for the C function!
        if (phy@order=="preorder") {
            edge <- phy@edge
        } else {
            edge <- reorder(phy, order="preorder")@edge
        }
        ## extract edge columns
        ancestor <- as.integer(edge[, 1])
        descendant <- as.integer(edge[, 2])
        
        ## TODO: REPLACE C call with OMP inplementation of descendants
        ## return indicator matrix of ALL descendants (including self)
        isDes <- .Call("OMPdescendants", node, ancestor, descendant)
        storage.mod## get descendants [recursively]
OMPdescendants <- function (phy, node, type=c("tips","children","all")) {
    type <- match.arg(type)

    ## look up nodes, warning about and excluding invalid nodes
    oNode <- node
    node <- getNode(phy, node, missing="warn")
    isValid <- !is.na(node)
    node <- as.integer(node[isValid])

    if (type == "children") {
        res <- lapply(node, function(x) children(phy, x))
        ## if just a single node, return as a single vector
        if (length(res)==1) res <- res[[1]]
    } else {
        ## edge matrix must be in preorder for the C function!
        if (phy@order=="preorder") {
            edge <- phy@edge
        } else {
            edge <- reorder(phy, order="preorder")@edge
        }
        ## extract edge columns
        ancestor <- as.integer(edge[, 1])
        descendant <- as.integer(edge[, 2])
        
        ## TODO: REPLACE C call with OMP inplementation of descendants
        ## return indicator matrix of ALL descendants (including self)
        isDes <- .Call("OMPdescendants", node, ancestor, descendant)
        storage.mode(isDes) <- "logical"

        ## for internal nodes only, drop self (not sure why this rule?)
        int.node <- intersect(node, nodeId(phy, "internal"))
        isDes[cbind(match(int.node, descendant),
            match(int.node, node))] <- FALSE
        
        ## if only tips desired, drop internal nodes
        if (type=="tips") {
            isDes[descendant %in% nodeId(phy, "internal"),] <- FALSE
        }
        
        res <- getNode(phy, descendant[isDes[, seq_along(node)]])
    }

    res
}#OMPdescendants

## get ancestors (all nodes)
OMPancestors <- function (phy, node, type=c("all","parent","ALL")) {
    type <- match.arg(type)

    ## look up nodes, warning about and excluding invalid nodes
    oNode <- node
    node <- getNode(phy, node, missing="warn")
    isValid <- !is.na(node)
    node <- as.integer(node[isValid])

    if (length(node) == 0) {
      return(NA)
    }
    
    if (type == "parent") {
        res <- lapply(node, function(x) ancestor(phy, x))
    } else {
        ## edge matrix must be in postorder for the C function!
        if (phy@order=="postorder") {
            edge <- phy@edge
        } else {
            edge <- reorder(phy, order="postorder")@edge
        }
        ## extract edge columns
        ancestor <- as.integer(edge[, 1])
        descendant <- as.integer(edge[, 2])
        
        ## TODO: REPLACE C call with OMP inplementation of ancestors
        ## return indicator matrix of ALL ancestors (including self)
        isAnc <- .Call("OMPancestors", node, ancestor, descendant)
        storage.mode(isAnc) <- "logical"

        ## drop self if needed
        if (type=="all") {
            isAnc[cbind(match(node, descendant), seq_along(node))] <- FALSE
        }
        res <- lapply(seq_along(node), function(n) getNode(phy,
            descendant[isAnc[,n]]))
    }
    names(res) <- as.character(oNode[isValid])

    ## if just a single node, return as a single vector
    if (length(res)==1) res <- res[[1]]
    res
}#OMPancestors

OMPMRCA <- function(phy, ...) {
    nodes <- list(...)
    ## if length==1 and first element is a vector,
    ##   use it as the list
    if (length(nodes)==1 && length(nodes[[1]])>1) {
        nodes <- as.list(nodes[[1]])
    }

    ## Correct behavior when the root is part of the nodes
    testNodes <- lapply(nodes, getNode, x=phy)
    ## BMB: why lapply, not sapply?
    lNodes <- unlist(testNodes)
    if (any(is.na(lNodes)))
      stop("nodes not found in tree: ",paste(names(lNodes)[is.na(lNodes)],
                                             collapse=", "))
    uniqueNodes <- unique(testNodes)
    root <- nTips(phy)+1
    ## Handles case where root is a node of interest, return root
    if(root %in% uniqueNodes) {
        res <- getNode(phy, root)
        return(res)
    }
    ## Correct behavior in case of MRCA of identical taxa
    if(length(uniqueNodes) == 1) {
        res <- uniqueNodes[[1]]
        return(res)
    }
    else { ## else length(uniqueNodes > 1)
        ancests <- lapply(nodes, OMPancestors, phy=phy, type="ALL")
        res <- getNode(phy, max(Reduce(intersect, ancests)))
        return(res)
    }
}#OMPMRCA


###############
# shortestPath
###############
OMPshortestPath <- function(phy, node1, node2){
  ## conversion from phylo, phylo4 and phylo4d
  if (class(phy) == "phylo4d") {
    x <- extractTree(phy)
  }
  else if (class(phy) != "phylo4"){
    x <- as(phy, "phylo4")
  }

    ## some checks
    ## if (is.character(checkval <- checkPhylo4(x))) stop(checkval) # no need
    t1 <- getNode(x, node1)
    t2 <- getNode(x, node2)
    if(any(is.na(c(t1,t2)))) stop("wrong node specified")
    if(t1==t2) return(NULL)

    ## main computations
    comAnc <- OMPMRCA(x, t1, t2) # common ancestor
    desComAnc <- OMPdescendants(x, comAnc, type="all")
    ancT1 <- OMPancestors(x, t1, type="all")
    path1 <- intersect(desComAnc, ancT1) # path: common anc -> t1

    ancT2 <- OMPancestors(x, t2, type="all")
    path2 <- intersect(desComAnc, ancT2) # path: common anc -> t2

    res <- union(path1, path2) # union of the path
    ## add the common ancestor if it differs from t1 or t2
    if(!comAnc %in% c(t1,t2)){
        res <- c(comAnc,res)
    }

    res <- getNode(x, res)

    return(res)
} # end shortestPathe(isDes) <- "logical"

        ## for internal nodes only, drop self (not sure why this rule?)
        int.node <- intersect(node, nodeId(phy, "internal"))
        isDes[cbind(match(int.node, descendant),
            match(int.node, node))] <- FALSE
        
        ## if only tips desired, drop internal nodes
        if (type=="tips") {
            isDes[descendant %in% nodeId(phy, "internal"),] <- FALSE
        }
        
        res <- getNode(phy, descendant[isDes[, seq_along(node)]])
    }

    res
}#OMPdescendants

## get ancestors (all nodes)
OMPancestors <- function (phy, node, type=c("all","parent","ALL")) {
    type <- match.arg(type)

    ## look up nodes, warning about and excluding invalid nodes
    oNode <- node
    node <- getNode(phy, node, missing="warn")
    isValid <- !is.na(node)
    node <- as.integer(node[isValid])

    if (length(node) == 0) {
      return(NA)
    }
    
    if (type == "parent") {
        res <- lapply(node, function(x) ancestor(phy, x))
    } else {
        ## edge matrix must be in postorder for the C function!
        if (phy@order=="postorder") {
            edge <- phy@edge
        } else {
            edge <- reorder(phy, order="postorder")@edge
        }
        ## extract edge columns
        ancestor <- as.integer(edge[, 1])
        descendant <- as.integer(edge[, 2])
        
        ## TODO: REPLACE C call with OMP inplementation of ancestors
        ## return indicator matrix of ALL ancestors (including self)
        isAnc <- .Call("OMPancestors", node, ancestor, descendant)
        storage.mode(isAnc) <- "logical"

        ## drop self if needed
        if (type=="all") {
            isAnc[cbind(match(node, descendant), seq_along(node))] <- FALSE
        }
        res <- lapply(seq_along(node), function(n) getNode(phy,
            descendant[isAnc[,n]]))
    }
    names(res) <- as.character(oNode[isValid])

    ## if just a single node, return as a single vector
    if (length(res)==1) res <- res[[1]]
    res
}#OMPancestors

OMPMRCA <- function(phy, ...) {
    nodes <- list(...)
    ## if length==1 and first element is a vector,
    ##   use it as the list
    if (length(nodes)==1 && length(nodes[[1]])>1) {
        nodes <- as.list(nodes[[1]])
    }

    ## Correct behavior when the root is part of the nodes
    testNodes <- lapply(nodes, getNode, x=phy)
    ## BMB: why lapply, not sapply?
    lNodes <- unlist(testNodes)
    if (any(is.na(lNodes)))
      stop("nodes not found in tree: ",paste(names(lNodes)[is.na(lNodes)],
                                             collapse=", "))
    uniqueNodes <- unique(testNodes)
    root <- nTips(phy)+1
    ## Handles case where root is a node of interest, return root
    if(root %in% uniqueNodes) {
        res <- getNode(phy, root)
        return(res)
    }
    ## Correct behavior in case of MRCA of identical taxa
    if(length(uniqueNodes) == 1) {
        res <- uniqueNodes[[1]]
        return(res)
    }
    else { ## else length(uniqueNodes > 1)
        ancests <- lapply(nodes, OMPancestors, phy=phy, type="ALL")
        res <- getNode(phy, max(Reduce(intersect, ancests)))
        return(res)
    }
}#OMPMRCA


###############
# shortestPath
###############
OMPshortestPath <- function(phy, node1, node2){
  ## conversion from phylo, phylo4 and phylo4d
  if (class(phy) == "phylo4d") {
    x <- extractTree(phy)
  }
  else if (class(phy) != "phylo4"){
    x <- as(phy, "phylo4")
  }

    ## some checks
    ## if (is.character(checkval <- checkPhylo4(x))) stop(checkval) # no need
    t1 <- getNode(x, node1)
    t2 <- getNode(x, node2)
    if(any(is.na(c(t1,t2)))) stop("wrong node specified")
    if(t1==t2) return(NULL)

    ## main computations
    comAnc <- OMPMRCA(x, t1, t2) # common ancestor
    desComAnc <- OMPdescendants(x, comAnc, type="all")
    ancT1 <- OMPancestors(x, t1, type="all")
    path1 <- intersect(desComAnc, ancT1) # path: common anc -> t1

    ancT2 <- OMPancestors(x, t2, type="all")
    path2 <- intersect(desComAnc, ancT2) # path: common anc -> t2

    res <- union(path1, path2) # union of the path
    ## add the common ancestor if it differs from t1 or t2
    if(!comAnc %in% c(t1,t2)){
        res <- c(comAnc,res)
    }

    res <- getNode(x, res)

    return(res)
} # end shortestPath
\end{lstlisting}

\subsection{CUDA Code}

Here are some highlights of the coming CUDA code.\\

Line 7: Node struct – contains information about tree's nodes (node id, ancestor id, node label) \\

Line 13: setNode function – translates R tree nodes to node structs \\

Line 22: kernel function – GPU function that computes ancestors of all nodes in the tree \\

Line 67: shortestPath function – takes an array of nodes, number of nodes given, and two character array labels and finds the shortest path between the given nodes. An error message is printed if the given nodes are invalid input (ex: they are a parent-child) \\

Line 196: main function – driver function, reads in input and calls the shortestPath function \\

\begin{lstlisting}[style=MyC++Style]
#include <stdio.h>
#include <stdlib.h>
#include <cuda.h>

//to compile: nvcc shortestPath.cu

struct node
{
	int nodeID, ancestor;
	char label[20]; //max size of label is 20
};//node

void setNode(node &phy, int numNodes, int id, int aID, char * label)
{
	phy.nodeID = id;
	phy.ancestor = aID;
	memset(phy.label, '\0', sizeof(label));
	strcpy(phy.label, label);
}//setNode


__global__ void kernel(node * array, int numNodes, int id1, int id2,
											int * ancestorID1, int * ancestorID2)
{
	int idx = blockIdx.x * blockDim.x + threadIdx.x;
	if (idx < numNodes)
	{
		if (array[idx].nodeID == id1) //if found target node
		{
			int ancestorIndex = 0;
			node temp = array[idx]; //start from current node
			while (temp.ancestor != 0)
			{
				ancestorID1[ancestorIndex++] = temp.ancestor; //add all ancestors
				for (int i=0; i<numNodes; i++)
				{
					if (array[i].nodeID == temp.ancestor)
					{
						temp = array[i];
						break;
					}//if
				}//for
			}//while
		}//if	
		else if (array[idx].nodeID == id2) //if found target node
		{
			int ancestorIndex = 0;
			node temp = array[idx]; //start from current node
			while (temp.ancestor != 0)
			{
				ancestorID2[ancestorIndex++] = temp.ancestor; //add all ancestors
				for (int i=0; i<numNodes; i++)
				{
					if (array[i].nodeID == temp.ancestor)
					{
						temp = array[i];
						break;
					}//if
				}//for
			}//while
		}//if
	
	}//if
}//kernel


void shortestPath(node * phy, int numNodes, char * label1, char * label2)
{
	node * deviceArray;
	int * deviceID1;
	int * deviceID2;
	int * ancestorID1 = new int[numNodes]; //initialize max size to number of nodes
	int * ancestorID2 = new int[numNodes];
	float blockSize = 1024; //num threads per block

	//check if invalid query
	node temp1, temp2;
	for (int i=0; i<numNodes; i++)
	{
		ancestorID1[i] = 0;
		ancestorID2[i] = 0;
		if (strcmp(label1, phy[i].label) == 0)
			temp1 = phy[i];
		else if (strcmp(label2, phy[i].label) == 0)
			temp2 = phy[i];
	}//for

	if ((temp1.ancestor == temp2.nodeID) || (temp2.ancestor == temp1.nodeID))
	{
		printf("named integer(0)\n");
		return;
	}//if

	//allocate device memory
	cudaMalloc(&deviceArray, sizeof(node) * numNodes);
	cudaMalloc(&deviceID1, sizeof(int) * numNodes);
	cudaMalloc(&deviceID2, sizeof(int) * numNodes);
	cudaMemcpy(deviceArray, phy, sizeof(node) * numNodes, cudaMemcpyHostToDevice);	
	cudaMemcpy(deviceID1, ancestorID1, sizeof(int) * numNodes, cudaMemcpyHostToDevice);
	cudaMemcpy(deviceID2, ancestorID2, sizeof(int) * numNodes, cudaMemcpyHostToDevice);

	dim3 dimBlock(blockSize);
	dim3 dimGrid(ceil(numNodes/blockSize));

	//compute ancestors
	kernel <<< dimGrid, dimBlock >>> (deviceArray, numNodes, temp1.nodeID, temp2.nodeID, deviceID1, deviceID2);
	cudaMemcpy(ancestorID1, deviceID1, sizeof(int) * numNodes, cudaMemcpyDeviceToHost);
	cudaMemcpy(ancestorID2, deviceID2, sizeof(int) * numNodes, cudaMemcpyDeviceToHost);
	cudaFree(deviceArray);
	cudaFree(deviceID1);
	cudaFree(deviceID2);

	//find shortest path
	int * path = new int[numNodes];
	int currentPath = ancestorID1[0];
	int pathIndex = 0;
	bool isLCAPath = false;
	//check if path converges at LCA
	for (int i=0; i<numNodes; i++)
	{
		path[i] = 0;
		if (temp1.nodeID == ancestorID2[i])
		{
			for (int j=0; j<i; j++)
				path[j] = ancestorID2[j];
			isLCAPath = true;
			break;
		}//if	
		else if (temp2.nodeID == ancestorID1[i])
		{	
			for (int j=0; j<i; j++)
				path[j] = ancestorID1[j];
			isLCAPath = true;
			break;
		}//else if
	}//for

	//if one node is the ancestor of another
	if (!isLCAPath)
	{
		for(int i=0; i<numNodes; i++)
		{	
			for (int j=0; j<numNodes; j++)
			{
				if (currentPath == ancestorID2[j])
					break;
				if ((ancestorID2[j] == 0) || (j == numNodes-1))
				{
					path[pathIndex++] = ancestorID1[i];
					currentPath = ancestorID1[i];
					break;
				}//if
			}//for	
		}//for		

		if (pathIndex == 0)	
			path[pathIndex++] = currentPath;
	
		for (int i=0; i<numNodes; i++)
		{
			if (ancestorID2[i] == currentPath)
				break;
			path[pathIndex++] = ancestorID2[i];
		}//for
	}//if

	for (int i=0; i<numNodes; i++)
	{
		if (path[i] == 0)
			break;
		for (int j=0; j<numNodes; j++)
		{
			if (path[i] == phy[j].nodeID)
			{
				printf("%s ", phy[j].label);
				break;
			}//if
		}//for
	}//for

	printf("\n");
	for (int i=0; i<numNodes; i++)
	{
		if (path[i] == 0)
			break;
		printf("%d ", path[i]);	
	}//for
	printf("\n");

	delete [] ancestorID1;
	delete [] ancestorID2;
	delete [] path;
}//shortestPath


int main()
{
	int numNodes = 27;
	node * phy = new node[numNodes];
	FILE * infile = fopen("geospiza", "r");
	
	int nodeID, ancestor;
	char label[20];
	for (int i=0; i<numNodes; i++)
	{
		fscanf(infile, "%d", &nodeID);
		fscanf(infile, "%d", &ancestor);
		fscanf(infile, "%s", &label);
		setNode(phy[i], numNodes, nodeID, ancestor, label);
	}//for
	fclose(infile);

//test shortest path
	shortestPath(phy, numNodes, "fusca", "fortis"); 
	
	delete [] phy;
	return 0;
}//main


\end{lstlisting}

\section{Who Did What} \label{App:AppendixB}
% the \\ insures the section title is centered below the phrase: Appendix B

Alicia wrote the OpenMP implementation. Bryan wrote the CUDA implemenation. Raymond wrote the RSnow implementation. We worked on running tests and writing the report in  \LaTeX.

\newpage

\begin{thebibliography}{1}

  \bibitem{Michonneau} F. Michonneau, {\em http://cran.r-project.org/web/packages/phylobase/phylobase.pdf}  February 20, 2015.



\end{thebibliography}

\end{document}


